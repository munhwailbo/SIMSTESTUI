<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="grd_1.StyleInfo" xml:space="preserve">
    <value>Normal{Font:굴림, 9pt;}	Alternate{}	Fixed{BackColor:Gainsboro;ForeColor:ControlText;Border:Flat,1,ControlDark,Both;}	Highlight{BackColor:Highlight;ForeColor:HighlightText;}	Focus{}	Editor{}	Search{BackColor:Highlight;ForeColor:HighlightText;}	Frozen{BackColor:Beige;}	NewRow{}	EmptyArea{BackColor:WhiteSmoke;Border:Flat,1,ControlDarkDark,Both;}	GrandTotal{BackColor:Black;ForeColor:White;}	Subtotal0{BackColor:ControlDarkDark;ForeColor:White;}	Subtotal1{BackColor:ControlDarkDark;ForeColor:White;}	Subtotal2{BackColor:ControlDarkDark;ForeColor:White;}	Subtotal3{BackColor:ControlDarkDark;ForeColor:White;}	Subtotal4{BackColor:ControlDarkDark;ForeColor:White;}	Subtotal5{BackColor:ControlDarkDark;ForeColor:White;}	</value>
  </data>
  <data name="RichTextBox1.Text" xml:space="preserve">
    <value>&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;
&lt;HTML&gt;&lt;HEAD&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;
&lt;meta name="GENERATOR" content="Fog Creek CityDesk 1.0.7"&gt;
&lt;meta name="generator" content="Fog Creek CityDesk 2.0.20" /&gt;
&lt;meta name="citydesk" content="7EE7763A/634" /&gt;
&lt;title&gt;Joel on Software - The Joel Test: 나은 코딩을 위한 12단계&lt;/TITLE&gt;
&lt;STYLE type=text/css&gt;
&lt;!--

body {  font-family:  Georgia, "Times New Roman", Times, serif}
.slugTable {  border-top: #666666 solid 1px }
.slugText { color: #666666;
            font-weight: bold;
            font-family:  Arial; }
.teaser {  font-family:  Verdana, Arial, Helvetica, sans-serif; font-size: 75%}

--&gt;
&lt;/STYLE&gt;
&lt;/HEAD&gt;
&lt;BODY text=#000000 bgColor=#ffffff onload="if (self != top) top.location = self.location" dir="ltr"&gt;&lt;table cellspacing="0" cellpadding="0" width="640" align="center" border="0"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td colspan="3"&gt;&lt;a href="../index.html"&gt;&lt;img height="113" alt="Joel on Software" src="../Images/global.jpg" width="640" border="0" /&gt;&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;
&lt;td colspan="3"&gt;&lt;p&gt;&lt;font face="Verdana, Arial, Helvetica, sans-serif"&gt;&lt;i&gt;&lt;font size="5"&gt;Joel on Software&lt;/font&gt; &amp;nbsp; &lt;font size="2"&gt;조엘 온 소프트웨어&lt;/i&gt;&lt;/font&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p align="left"&gt;&amp;nbsp;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign="top" width="178"&gt;
      &lt;p&gt;&lt;font size="2"&gt;&lt;a href="../index.html"&gt;한글로된 다른 "Joel on Software" 글들&lt;/a&gt;&lt;/font&gt;&lt;/p&gt;

      &lt;p&gt;&lt;font size="2"&gt;&lt;a href="http://www.joelonsoftware.com/"&gt;영어로된 다른 "Joel on Software" 글들&lt;/a&gt;    &lt;/font&gt;&lt;/p&gt;
              
      &lt;p&gt;&lt;font size="2"&gt;&lt;a href="http://www.joelonsoftware.com/navLinks/fog0000000263.html"&gt;
      
      필자 메일주소(영어만 사용)&lt;/a&gt;&lt;/font&gt;&lt;/p&gt;
      
      &lt;p&gt;&lt;font size="2"&gt;&lt;a href="http://www.joelonsoftware.com/navLinks/fog0000000263.html"&gt;
      
      &lt;a href="http://www.acornpub.co.kr/new2/book/info/bookdetail.asp?bkcode=1297"&gt;&lt;img height="240" alt="" src="../Images/joel_korean_book_copy.jpg" width="160" border="0" /&gt;&lt;/a&gt;&lt;/a&gt;&lt;/font&gt;&lt;/p&gt;

      
	&lt;/td&gt;
&lt;td valign="top" width="12" rowspan="2"&gt;&lt;font size="1"&gt;&amp;nbsp;&lt;/font&gt;&lt;/td&gt;
&lt;td valign="top" width="450" rowspan="2"&gt;
&lt;table class="slugTable" cellspacing="0" cellpadding="0" width="100%" border="0"&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;

&lt;p class="slugText"&gt;
&lt;strong&gt;The Joel Test: 나은 코딩을 위한 12단계&lt;/strong&gt;
&lt;/p&gt;

&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;br /&gt;&lt;font color="#808080"&gt; &lt;/font&gt;&lt;font color="#808080"&gt;
    
&lt;font size="2"&gt;글 :  Joel Spolsky&lt;br /&gt;
번역 : B.K. Chung 정봉겸 &lt;br /&gt;
감수 : Jang Han Goo 구장한 &lt;br /&gt;
2000년 8월 9일&lt;br /&gt;&lt;/font&gt;&lt;br /&gt;
&lt;/font&gt;
  
&lt;P&gt;&lt;A href="http://www.sei.cmu.edu/sema/welcome.html"&gt;SEMA&lt;/A&gt;에 대해서 들어보신 적이 있습니까? 소프트웨어 팀이 얼마나 잘하는지를 재는 나름대로 복잡한 시스템입니다. 앗, 아니! 그 링크를 누르지 마세요. SEMA를 "이해"만 하는데 아마 6년정도가 걸릴것입니다. 그래서 소프트웨어 팀이 얼마나 좋은지 등급을 매길 수 있는 - 좀 무책임하고 되는대로의 - 자체적인 버젼의 테스트를 만들었습니다. 이 테스트의 장점은 3분정도밖에 걸리지 않는다는 것입니다. 절약되는 시간으로 의대에 가서 공부할 수도 있을 것입니다.&lt;/P&gt;
&lt;TABLE border=1&gt;
&lt;TBODY&gt;
&lt;TR&gt;
&lt;TD&gt;
&lt;P align=center&gt;&lt;FONT face="Arial Black,Arial,Helvetica" color=#333333 size=4&gt;The Joel Test&lt;/FONT&gt;&lt;/P&gt;
&lt;OL&gt;
&lt;LI&gt;Source Control(소스 컨트롤)을 사용하십니까? 
&lt;LI&gt;한번에 빌드를 만들어낼 수 있습니까? 
&lt;LI&gt;daily build(일별 빌드)를 만드십니까? 
&lt;LI&gt;버그 데이타베이스를 가지고 있습니까? 
&lt;LI&gt;새로운 코드를 작성하기 전에 버그들을 잡습니까? 
&lt;LI&gt;up-to-date(최신) 스케줄을 가지고 있습니까? 
&lt;LI&gt;spec(설계서)를 가지고 있습니까? 
&lt;LI&gt;프로그래머들이 조용한 작업환경을 가지고 있습니까? 
&lt;LI&gt;돈이 허락하는 한도내의 최고의 툴들을 사용하고 있습니까? 
&lt;LI&gt;테스터들을 고용하고 있습니까? 
&lt;LI&gt;신입사원들은 면접때 코드를 직접 짜는 실기시험을 봅니까? 
&lt;LI&gt;hallway usability testing(무작위 사용성 테스팅)을 하십니까? &lt;/LI&gt;&lt;/OL&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TBODY&gt;&lt;/TABLE&gt;
&lt;P&gt;Joel Test이 특별한 점은 각 직문에 예/아니오로 바로 대답할 수 있다는 것이다. lines-of-code-per-day(하루동안 산출되는 코드의 줄수)나 average-bugs-per-inflection-point(산출 시점의 평균 버그수) 같은 것은 알 필요가 없습니다. "예"에 해당 하는 질문에 1점씬 가산됩니다. 하지만 이 테스트는 핵 원자로에 사용하는 소프트웨어가 안전한지를 검사하는등 에는 사용하지 말아주십시오.&lt;/P&gt;
&lt;P&gt;12점은 완벽, 11은 충분한 점수이지만 10점이나 그 이하는 심각한 문제가 있다는 신호입니다. 사실은 대개의 소프트웨어 회사 들이 2~3점을 받고 있고, 심각한 도움을 필요로 하고 있습니다. Microsoft같은 회사는 12점 만점을 받고 있습니다.&lt;/P&gt;
&lt;P&gt;당연한 이야기지만 이것들만으로 성공과 실패를 가를 수는 없습니다. 특히, 아무도 필요없는 제품을 굉장히 훌륭한 소프트웨어 팀이 만들고 있다면, 역시나 아무도 원하지 않을 것입니다. 반대로 이런 방식을 따르지 않는 명인들이 세상을 바꾸는 소프트웨어 를 만드는 경우로 생각할 수 있겠습니다. 그러나, 이 12가지 이외의 요소를 모두 동등하게 놓고 본다면, 이들만 제대로 한다면 지속적으로 좋은 결과를 내는 잘 훈련된 팀이 될 것입니다.&lt;/P&gt;
&lt;P&gt;&lt;STRONG&gt;1. Source Control(소스 컨트롤)을 사용하십니까?&lt;/STRONG&gt; &lt;/P&gt;
&lt;P&gt;상용 소스 컨트롤 패키지들도 사용해보았고, 무료로 사용할 수 있는 &lt;A href="http://www.cvshome.org/"&gt;CVS&lt;/A&gt;도 사용해보았습니다. CVS는 무료이기는 하지만 충분합니다. 그렇지만 소스 컨트롤이 없다면 프로그래머들을 조율하는 일이 상당히 피곤할 것입니다. 프로그래머들은 다른 사람들이 어떤 것을 했는지 알 수 있는 방법이 없습니다. 이를 사용하면 실수를 쉽게 롤백할 수 있습니다. 소스 컨트롤의 다른 장점은 소스코드 자체가 모든 프로그래머의 하드디스크에 체크아웃(check out)되어 있다는 것입니다. 소스 컨트롤을 사용하는 프로젝트에서 코드를 날렸다는 이야기를 들어본 적이 없습니다.&lt;/P&gt;
&lt;P&gt;&lt;STRONG&gt;2. 한번에 빌드를 만들어낼 수 있습니까?&lt;/STRONG&gt; &lt;/P&gt;
&lt;P&gt;"최신의 소스로부터 몇단계를 거쳐서 완제품(shipping build)을 만들 수 있습니까?"라는 의미의 질문입니다. 잘 되어있는 팀인 경우라면 하나의 스크립트로 checkout부터 시작하여 각 소스를 리빌드(rebuild)하고 각 버젼, 언어, #ifdef같은 조건별로 실행파일을 만들어내어 마지막 CDROM 레이아웃, 다운로드할 수 있는 웹사이트를 만들어 내는 정도까지 되어 있을 수 있겠습니다.&lt;/P&gt;
&lt;P&gt;만일 이 과정이 하나의 단계 이상을 거친다면, 여기서부터 에러가 발생할 확률이 생깁니다. 정해진 기일이 가까워질수록 "마지막" 버그를 수정하고 실행파일을 만드는 등을 위해 빠른 사이클을 필요로 할 것입니다. 코드를 컴파일하고 설치파일을 구성하는데에 20단계가 필요하다면 급박한 시간때문에 사소한 실수를 저지르게 될 것입니다.&lt;/P&gt;
&lt;P&gt;필자가 마지막으로 근무했던 회사에서는 이런 이유로 WISE를 InstallShield(역자주 : 두 제품 모두 설치본을 만들기위한 도구 입니다.)로 교체하였습니다. 설치 과정을 스크립트를 통해서 NT 스케줄러로 밤새에 자동으로 실행하도록 하고자 하였는데, WISE는 스케줄러로 실행할 수 없던 이유입니다. (WISE의 친절한 분들이 최신 버젼에는 이것이 가능하다고 알려왔습니다.)&lt;/P&gt;
&lt;P&gt;&lt;STRONG&gt;3. daily build(일별 빌드)를 만드십니까?&lt;/STRONG&gt; &lt;/P&gt;
&lt;P&gt;소스 컨트롤을 사용하다 보면 누군가가 빌드를 실패하게 만드는 코드를 체크인 할 수 있습니다. 예를 들면, 새로운 소스파일을 추가해서 그 사람의 컴퓨터에서는 잘 컴파일되지만, 이를 코드 레파지토리(repository)에는 추가를 하지 않았을 수 있습니다. 이 사람은 이를 잊고 만족한 상태에서 컴퓨터를 잠그고 집에 돌아갑니다. 그렇지만 이로 인해 다른사람들은 작업을 할 수 없게 되고 결국 찝찝하지만 결과없이 집으로 돌아갈 수 밖에 없습니다.&lt;/P&gt;
&lt;P&gt;모르는 사이에 빌드를 실패하는 이런 컴파일 오류가 나지 않도록 daily build를 만들게 됩니다. 큰 팀에서는 이런 경우를 위해서 daily build를 매일 오후 - 점심시간등 - 에 합니다. 사람들은 점심시간 이전에 될 수 있는 한 많이 체크인을 합니다. 점심을 먹으로 갔다가 다시 돌아오면 빌드는 이루어져 있습니다. 빌드가 실패하면, 사람들은 빌드가 성공한 이전 소스로 작업을 하면 됩니다.&lt;/P&gt;
&lt;P&gt;엑셀팀에서는 누군가 빌드를 깨면 벌칙으로 다른 사람이 다시 깰때까지 빌드를 관리하도록 벌칙을 주었습니다. 이는 빌드를 깨면 받는 벌칙으로써 뿐만 아니라 모든 이들이 돌아가면서 빌드를 관리할 수 있게하여, 어떻게 돌아가는 지를 익히게 하는 방법으로써도 좋았습니다.&lt;/P&gt;
&lt;P&gt;daily build에 관해 더 자세히 아시려면 저의 기사 &lt;A href="http://www.joelonsoftware.com/articles/fog0000000023.html"&gt;daily builds are your friend&lt;/A&gt;를 읽으십시오.&lt;/P&gt;
&lt;P&gt;&lt;STRONG&gt;4. 버그 데이타베이스를 가지고 있습니까?&lt;/STRONG&gt; &lt;/P&gt;
&lt;P&gt;뭐라고 반박하셔도 확신합니다. 코드를 짜고 있다면 설령 혼자 짜더라도 정리된 버그 명세 데이타베이스를 가지고 있지 않다면 낮은 질의 코드로 제품을 출시할 것입니다. 많은 프로그래머들이 머리로 버그들을 모두 기억할 것이라고 생각합니다. 말도 안되는 이야기입니다. 제 경우에는 한번에 2~3개의 버그밖에 기억을 못하고, 다음날이 되거나 출시를 위해 급해지면 전부 잊어버리게 됩니다. 버그를 제대로 트래킹해야합니다.&lt;/P&gt;
&lt;P&gt;버그 데이타베이스는 복잡할 수도 있고, 간단할 수도 있습니다. 최소한으로 갖추어야할 요소는 다음과 같습니다:&lt;/P&gt;
&lt;UL&gt;
&lt;LI&gt;버그를 완벽하게 재현할 수 있는 과정 
&lt;LI&gt;버그가 없었다면 이루어졌어야할 결과(동작) 
&lt;LI&gt;버그로 인하여 생긴 결과(동작) 
&lt;LI&gt;누가 이 버그에 할당되어 있는지 
&lt;LI&gt;고쳐진 버그인지 아닌지 &lt;/LI&gt;&lt;/UL&gt;
&lt;P&gt;버그 데이타베이스를 사용하지 않는 이유가 제품들이 너무 복잡해서라면, 이것들을 포함한 5컬럼의 테이블을 만들어서 사용하기 시작하세요.&lt;/P&gt;
&lt;P&gt;버그 트래킹에 관해 더 읽으려면, &lt;A href="http://www.joelonsoftware.com/articles/fog0000000029.html"&gt;Painless Bug Tracking&lt;/A&gt;을 읽으세요.&lt;/P&gt;
&lt;P&gt;&lt;STRONG&gt;5. 새로운 코드를 작성하기 전에 버그들을 잡습니까?&lt;/STRONG&gt; &lt;/P&gt;
&lt;P&gt;마이크로소프트 Windows용 Word의 첫 버젼은 죽음의 프로젝트였습니다. 끝이 없었습니다. 계속해서 스케줄을 펑크냈습니다. 팀 전체는 말도 안되는 시간동안 일했고, 계속해서 연기되고 또 연기되었습니다. 그 스트레스는 엄청났습니다. 빌어먹을 제품이 몇년 후에 출시되었을때, 마이크로소프트는 팀 전원을 Cancun으로 휴가보내고, 이 원인을 분석하기 시작했습니다.&lt;/P&gt;
&lt;P&gt;그들이 깨닫게 된 것은 프로젝트 매니저들이 스케줄을 너무 강요하였기 때문에 프로그래머들은 코딩을 빨리 할 수 밖에 없었습니다. 게다가 버그를 고치는 단계는 스케줄에 아예 존재하지 않았습니다. 결과적으로 질이 아주 나쁜 코드를 만들게 되었습니다. 버그 갯수를 줄이려는 노력은 전혀 하지 않았습니다. 한 프로그래머는 텍스트의 높이를 계산하는 루틴 대신에 "return 12;"로 대체하여 버그 리포트로부터 이 값이 어떤 영향을 주었는지를 알고자 했습니다. 스케줄은 단지 버그일 수 밖에 없는 기능들을 모아 놓은 체크리스트였습니다. 나중에 이 상황을 "무한 결함 방식(infinite defects methodology)"이라고 이름지었습니다.&lt;/P&gt;
&lt;P&gt;문제를 해결하기 위해서 마이크로소프트는 반대의 "무결함 방식(zero defects methodology)"라는 방식을 체택했습니다. 많은 프로그래머들은 경영진들의 명령에 의해서 버그 갯수를 줄일 수 있다고 생각했음직한 이 방식의 이름 탓에 이를 비웃었습니다. 하지만 실제로는 "무결함(zero defects)"이라는 이름은 주어진 시간에 가장 우선순위가 높은 것은 코딩하기전에 버그를 잡는 것이란 사실을 지칭하는 말이었습니다. 이유는 다음과 같습니다.&lt;/P&gt;
&lt;P&gt;일반적으로 버그를 고치지 않고 방치하는 시간이 길어지면 길어질수록 고치는데 더 많은 시간과 금전이 요구된다는 것입니다.&lt;/P&gt;
&lt;P&gt;예를 들면, 오타나 문법오류등은 컴파일러가 쉽게 잡아서 고치는데도 별로 문제가 되지 않습니다.&lt;/P&gt;
&lt;P&gt;만일 버그가 처음 실행시에 발생하여 보이게 되면, 모든 코드가 머릿속게 생생하게 존재하기에 바로 고칠 수 있을 것입니다.&lt;/P&gt;
&lt;P&gt;며칠전에 작성한 코드에서 버그를 찾게 되면 이를 고치기 위해 조금 시간이 더 걸릴 것입니다. 아마도 코드를 다시 보게 되면 대부분의 내용이 기억나고 적정한 시간내에 버그를 고칠 수 있을 것입니다.&lt;/P&gt;
&lt;P&gt;하지만 몇달전에 작성한 코드에서 버그가 발견된다면 이미 그 코드에 관해서 많은 것이 이미 생각나지 않을 것이고, 고치기도 상대적으로 힘들 것입니다. 그때쯤 되면 다른 사람의 코드를 수정하고 있는 와중일지도 모르고, 그사람은 Aruba로 휴가를 떠나있을지도 모릅니다. 이렇게 된다면 버그를 고치는 것은 기술을 익히는 것같이 되어버릴 것입니다. 천천히 꼼꼼하게 그리고 주의 깊게 코드를 살펴봐야 하고, 물론 문제를 해결하는데에 얼마나 걸릴지 정확하게 판단하기 힘든 상황이 될 것입니다.&lt;/P&gt;
&lt;P&gt;게다가 이미 출하된 코드에서 버그를 발견한다면, 이를 고치는데에 큰 대가를 치뤄야할지도 모를 것입니다.&lt;/P&gt;
&lt;P&gt;이렇게 시간이 적게 들기 때문이라는 이유가 하나의 이유가 됩니다. 또다른 이유는 버그를 수정하는데 걸리는 시간을 예상하는 것보다는 새로운 코드를 작성하는데 걸리는 시간을 예상하기가 훨씬 쉽기 때문입니다. 예를 들면, 내가 당신에게 리스트를 소트하는 코드를 만드는데 얼마나 걸리냐고 물어본다면, 꽤 정확한 대답을 할 수 있을 것입니다. 그렇지만, 질문을 바꿔서 당신의 코드가 Internet Explorer 5.5만 설치되어있으면 동작하지 않는 버그를 고치는데 걸리는 시간을 묻는다면, 문제가 무엇인지도 모르는 상황이기 때문에 얼마나 걸릴지 추측하지도 못할 것입니다. 3일이 걸릴 수도 있을 것이고, 운좋으면 2분이 걸릴 수도 있을 것입니다.&lt;/P&gt;
&lt;P&gt;이것이 의미하는 바는 고쳐야할 버그가 많이 존재하는 상태의 스케줄이라면 그 스케줄은 정확할 수가 없다는 것입니다. 그렇지만 이미 알고있는 버그들은 모두 고친 상태라면 그 스케줄은 상대적으로 상당히 정확하게 지킬 수 있는 스케줄일 것입니다.&lt;/P&gt;
&lt;P&gt;버그 갯수를 0에 가깝게 하는 또하나의 좋은 점은 경쟁에서 훨씬 빠르게 대응할 수 있다는 것입니다. 어떤 프로그래머들은 이를 두고 제품을 바로 출하할 수 있는 항상 유지하는 것이라고 이야기합니다. 경쟁자가 고객들을 가로채갈만한 굉장히 좋은 기능을 새로 만들었다면 축척된 많은 버그를 수정할 필요없이 바로 이 기능을 추가할 수 있을 것입니다.&lt;/P&gt;
&lt;P&gt;&lt;STRONG&gt;6. up-to-date(최신) 스케줄을 가지고 있습니까?&lt;/STRONG&gt; &lt;/P&gt;
&lt;P&gt;비즈니스에 당신의 코드가 조금이라도 중요한 부분이라면, 코드가 언제쯤 완성될 수 있는지를 아는 것 또한 중요하다는 것은 당연할 것입니다. 프로그래머들은 엉터리 스케줄을 만드는데 악명이 높습니다. "언젠가는 될꺼야!"하고 외칩니다.&lt;/P&gt;
&lt;P&gt;불행하게도 그런 식으로는 해결할 수 있는것은 없습니다. 비즈니스에는 코드를 출하하기 전에 데모, 전시회, 광고등등 미리 많은 것들을 판단하여 결정해야합니다. 이를 할 수 있는 단 한가지 방법은 스케줄을 가지고 이를 계속해서 현실적으로 최신내용으로 유지하는 것입니다.&lt;/P&gt;
&lt;P&gt;스케줄을 가져야하는 또다른 중요한 이유는 이를 통해서 어떤 기능이 필요한지를 결정하게끔 만들어준다는 것입니다. 때문에 어떤 기능이 덜 중요한지 결정해야하고 &lt;A href="http://www.netmeg.net/jargon/terms/c/creeping_featuritis.html"&gt;featuris&lt;/A&gt; 가 되기 전에 이들을 포기하도록 합니다.&lt;/P&gt;
&lt;P&gt;스케줄을 관리하는 것이 어려울 필요는 없습니다. 제 글&lt;A href="http://www.joelonsoftware.com/articles/fog0000000245.html"&gt;Painless Software Schedules&lt;/A&gt; 에 좋은 스케줄을 만드는 간단한 방법을 설명하였습니다.&lt;/P&gt;
&lt;P&gt;&lt;STRONG&gt;7. spec(설계서)를 가지고 있습니까?&lt;/STRONG&gt; &lt;/P&gt;
&lt;P&gt;스펙을 만드는 것은 이빨을 쑤시는것과 같습니다: 모든 사람들이 좋다고 인정하지만, 아무도 하지 않습니다.&lt;/P&gt;
&lt;P&gt;왜 그런 현상이 일어나는지는 정확히 모르겠습니다만, 아마도 프로그래머들이 문서를 만드는 것을 굉장히 싫어하는데에 기인하는 것 같습니다. 그 결과로, 프로그래머밖에 없는 집단에서 한가지 문제를 해결하고자 하면, 이들은 문서를 만들기 보다는 코드로 자신들의 의견을 표명하려 합니다. 스펙을 먼저 만들기보다는 차라리 코드를 짜서 보여주는 것을 택한다는 것입니다.&lt;/P&gt;
&lt;P&gt;설계 단계에서 문제를 발견하면 몇줄을 고쳐서 이를 수정할 수 있습니다. 그렇지만 코드가 짜여진 상황이라면 이 문제를 수정하는 댓가는 감정적으로나(코드를 그냥 버리는 것을 좋아하는 사람은 없습니다) 시간적으로나 훨씬 높게 되고 더 힘든 작업이 되어버립니다. 스펙을 통해서 만들어지지 않은 소프트웨어는 대개 설계가 잘못되어 스케줄을 엉망으로 만들어놓습니다. Netscape에서도 이런 문제로 인해 브라우저의 초기 네개의 버젼이 너무 엉망이 되어 결국 관리자들이 &lt;A href="http://www.joelonsoftware.com/articles/fog0000000069.html"&gt;멍청하게도 코드를 전부 버리고 다시 짜도록한 결정&lt;/A&gt;을 내려버리게 되는 상황이 벌어졌습니다. 거기다 한술 더 떠서 Mozilla에서 이런 실수를 다시 반복하여 겨우 Alpha 단계에 가는데 몇년이라는 시간이 걸리게 되었습니다.&lt;/P&gt;
&lt;P&gt;필자의 지론은 이 문제는 프로그래머들이 문서를 작성하는데 거부감이 없도록 &lt;A href="http://www.yale.edu/engl450b/"&gt;작문 강의&lt;/A&gt;를 듣도록 보내는 것으로 해결할 수 있다는 것입니다. 다른 해결책이라면 스펙같은 문서 작성에 능숙한 관리자를 두는 것입니다. 두 경우 모두 "스펙없는 코드는 금물"이라는 간단한 규칙을 따라야 할 것입니다.&lt;/P&gt;
&lt;P&gt;저의 &lt;A href="http://www.joelonsoftware.com/articles/fog0000000036.html"&gt;4부짜리 글&lt;/A&gt;에 스펙 작성하는 요령에 대해 이야기했습니다.&lt;/P&gt;
&lt;P&gt;&lt;STRONG&gt;8. 프로그래머들이 조용한 작업환경을 가지고 있습니까?&lt;/STRONG&gt; &lt;/P&gt;
&lt;P&gt;지식 근로자에게 공간, 조용함, 프라이버시를 줌으로해서 많은 생산성 향상을 얻는다는 것은 이미 증명된 사실입니다. 소프트웨어 관리의 고전인 &lt;A href="http://www.amazon.com/exec/obidos/ASIN/0932633439/ref=nosim/joelonsoftware/"&gt;Peopleware&lt;/A&gt;에서는 이 생산성 향상에 대해 자세히 기술합니다.&lt;/P&gt;
&lt;P&gt;문제는 여기에 있습니다. 지식 근로자는 "in the zone"상태라고도 하는 "flow"상태에 들어섬으로써 가장 최상의 상태가 되어 일에 완벽히 집중하고 외부에 개의치 않게 됩니다. 완벽한 집중으로 시간 가는 것을 잊고 좋은 결과를 내게 됩니다. 이때에 바로 대부분의 생산적인 일들을 처리하게 됩니다. 작가, 프로그래머, 과학자 그리고 심지어 농구선수들까지도 "in the zone"상태가 있음을 이야기할 것입니다.&lt;/P&gt;
&lt;P&gt;문제는 "zone"으로 들어가는 것이 쉽지 않다는 것입니다. 측정해보면, 최상의 생산성으로 일을 하기 위해서는 평균 15분이 걸립니다. 하지만 어떤 경우에는 피곤하고 이미 많은 일을 한 상태에서 "zone"상태에 들어가지 못하고 다른 일을 하거나 웹서핑이나 테트리스로 시간을 허비하게 될 수도 있습니다.&lt;/P&gt;
&lt;P&gt;또다른 문제는 "zone"상태에서 빠져나가는 것이 매우 쉽다는 것입니다. 잡음, 전화소리, 점심식사, 잠시 스타벅스에 5분간 갔다오는 것 그리고 특히 동료에 의한 방해등에 의해 바로 "zone"에서 빠져나가게 됩니다. 동료가 1분이라는 짧은 시간 동안이라도 질문을 하여 "zone"상태에서 빠져나간다면 다시 되돌아가기 위해서 30분이 넘는 시간이 걸려 전체 효율에 치명적인 영향을 미칠 수 있습니다. 카페인 가득한 닷컴 회사들이 좋아하는 합숙소같은 곳에 옆의 마케팅 부서에서 계속해서 오는 전화에 대고 소리지르는 그런 시끄러운 환경이라면 계속된 방해로 지식 근로자들의 생산성은 추락하여 "zone"상태에 절대 이르지 못할 수도 있습니다. &lt;/P&gt;
&lt;P&gt;프로그래머들에게 있어서 특히 어렵습니다. 생산성은 단기적인 기억력으로 한번에 얼마나 많은 작은 세부사항들을 다루느냐에 달려있습니다. 어떠한 방해도 이런 세부사항들을 잊어버리게 할 수 있습니다. 일을 다시 재개하면 그것들을 다시 기억하지 못하여 (사용하던 지역변수나 검색 알고리즘을 만들던 중에 어디에서 멈줬었는지등) 다시 찾아보게 되고, 이로 인해 다시 속도가 붙을때까지 느려지게 됩니다. &lt;/P&gt;
&lt;P&gt;직관적으로 계산해보면 다음과 같습니다. 만일 프로그래머가 단 1분이라도 방해를 받아서(명백한 근거에 의해) 15분의 생산성을 날려버린다고 합시다. 철수와 영희 두 프로그래머가 낮은 칸막이로 주욱 늘어선(a standard Dilbert veal-fattening farm) 열린 사각 파티션 옆자리에 앉아 있다고 합시다. 영희가 strcpy함수의 유니코드 버젼 이름을 잊었습니다. 30초면 찾아볼 수 있겠지만, 철수한테 물어보면 15초가 걸립니다. 그래서 바로 옆에 앉아 있는 철수에게 묻습니다. 철수는 산만해지고 - 영희의 15초를 아끼기 위해 - 15분을 낭비하게 됩니다.&lt;/P&gt;
&lt;P&gt;이번에는 벽과 문으로 나뉘어진 별도의 사무실로 가정을 합시다. 여전히 영희는 함수를 기억하지 못합니다. 다시 찾아보는 것으로 30초를 보낼 수 있을 것이고 옆 방에 있는 철수에게 물어보기 위해서 (일반적인 프로그래머의 평균 물리적인 건강상태를 봐서는 쉽지 않은) 일어나서 걷는 것을 포함한 45초를 보낼 수 있을 것입니다. 결국 찾아보는 것을 선택하여 30초를 보내게 되지만 철수의 15분을 벌어주게 됩니다. 대단하죠!&lt;/P&gt;
&lt;P&gt;&lt;STRONG&gt;9. 돈이 허락하는 한도내의 최고의 툴들을 사용하고 있습니까?&lt;/STRONG&gt; &lt;/P&gt;
&lt;P&gt;컴파일 되는 언어로 코드를 작성하는 것은 여전히 아무 PC에서 할 수 없는 것 중의 하나입니다. 컴파일을 하는데 몇초 이상 걸린다면 최상의 기종을 사용함으로써 시간을 절약할 수 있을 것입니다. 15초 이상 걸린다면 지루해서 그 시간동안 &lt;A href="http://www.theonion.com/"&gt;The Onion&lt;/A&gt;을 읽게 될 것이고 너무 재미있는 관계로 거기에 빠져 수시간의 생산성을 날려버릴 것입니다.&lt;/P&gt;
&lt;P&gt;모니터 하나로 GUI코드를 디버깅한 것은 불가능하지는 않지만 고통스러운 작업입니다. GUI코드를 작성하고 있다면, 2대의 모니터로 훨씬 쉬운 작업을 할 수 있을 것입니다.&lt;/P&gt;
&lt;P&gt;대개의 프로그래머들은 아이콘이나 툴바를 위해 비트맵을 수정해야하고 대부분의 프로그래머 역시 좋은 비트맵 에디터를 가지고 있지 않습니다. 마이크로소프트에서 기본적으로 제공하는 Paint 프로그램으로 비트맵을 수정하는 것은 웃긴 일이지만 대부분 이렇게 하고 있습니다.&lt;/P&gt;
&lt;P&gt;&lt;A href="http://www.joelonsoftware.com/articles/TwoStories.html"&gt;필자의 가장 최근 직장&lt;/A&gt;에서 시스템 관리자가 계속해서 자동적으로 스팸을 보냈습니다. 이유인 즉슨 220MB이상의 하드드라이브를 사용하고 있다는 것이었습니다. 필자는 요즘 HD가격을 본다면 이 공간의 환산된 가격은 내가 이용하는 화장실 휴지보다 싸다는 것을 지적했습니다. 디렉토리를 정리하기 위해 10분을 허비하는 정도로도 큰 생산성 저하일 것입니다.&lt;/P&gt;
&lt;P&gt;"최고의 개발팀은 절대 그들의 프로그래머들을 고문하지 않습니다!" 후진 제품으로 인한 작은 불편함이 쌓여서 프로그래머들이 불만에 찰 수도 있습니다. 그리고 그로 인한 불만에 찬 프로그래머는 비생산적인 프로그래머이기 쉬울 것입니다.&lt;/P&gt;
&lt;P&gt;이런 것들을 모두 종합하면 프로그래머들은 최고/최신의 것들로 쉽게 매수된다는 뜻이 됩니다. 이는 높은 연봉을 주는 것보다는 훨씬 싼 방법일 것입니다!&lt;/P&gt;
&lt;P&gt;&lt;STRONG&gt;10. 테스터들을 고용하고 있습니까?&lt;/STRONG&gt; &lt;/P&gt;
&lt;P&gt;팀이 최소한 2~3명의 프로그래머에게 테스팅만 전담하는 테스터가 할당되어 있지 않다면, 버그가 많은 제품을 출하하고 있거나 시간당 $100짜리 프로그래머에게 시간당 $30의 일을 시키는 낭비를 하고 있는 것입니다. 테스터를 고용하는 것이 낭비로 생각하는 것은 정말 잘못된 계산을 하고 있는 것이며, 많은 사람들이 이를 깨닫지 못하고 있는데에 놀랍니다.&lt;/P&gt;
&lt;P&gt;이에 관해 더 자세히 알고자 한다면 &lt;A href="http://www.joelonsoftware.com/articles/fog0000000067.html"&gt;Top Five (Wrong) Reasons You Don't Have Testers&lt;/A&gt; 를 읽으십시오.&lt;/P&gt;
&lt;P&gt;&lt;STRONG&gt;11. 신입사원들은 면접때 코드를 직접 짜는 실기시험을 봅니까?&lt;/STRONG&gt; &lt;/P&gt;
&lt;P&gt;마법사를 고용하는데 그의 마법을 보지 않고 고용하시겠습니까? 당연히 그렇지 않겠죠.&lt;/P&gt;
&lt;P&gt;결혼식에 요리사를 고용하는데 요리사가 만든 요리의 맛도 모르고 고용하시겠습니까? 그렇지 않을것입니다.(역자주: 실제로 결혼식장 요리사의 맛을 보는 비유는 우리나라에 맞지 않을 것 같네요. 이 문구의 뜻만 이해하세요)&lt;/P&gt;
&lt;P&gt;하지만 현실에서는 매일 인상적인 이력서나 면접에서 맘에 든 이유로 고용하는 일들이 일어납니다. 혹은 ("CreateDialog()와 DialogBox()의 차이점은 무엇입니까")등의 문서만 보면 알 수 있는 사소한 질문으로 채용하기도 합니다. 프로그래머를 채용하는데 있어서 중요한 것은 그런 사소한 것들을 얼마나 많이 외웠느냐가 아니고 코드를 잘 작성할 수 있느냐입니다. 혹은 "아하!"류의 질문으로 채용하기도 합니다. "아하!"류의 질문이란 답을 알면 간단하지만 모르는 경우에는 절대 맞출 수 없는 질문을 이야기합니다.&lt;/P&gt;
&lt;P&gt;제발 이런 방식을 그만 두십시오. 면접때 무얼해도 상관없지만 반드시 코드를 작성하도록 해야합니다.(더 많은 것을 알고 싶다면 &lt;A href="http://www.joelonsoftware.com/articles/fog0000000073.html"&gt;Guerrilla Guide to Interviewing&lt;/A&gt;를 읽으십시오)&lt;/P&gt;
&lt;P&gt;&lt;STRONG&gt;12. hallway usability testing(무작위 사용성 테스팅)을 하십니까?&lt;/STRONG&gt; &lt;/P&gt;
&lt;P&gt;무작위 사용성 테스트(hallway usability test)는 복도를 지나가는 다음 사람을 붙잡고 방금 짠 코드를 사용하게 하는 방식입니다. 5명에게 이 테스트를 한다면 95%의 사용성 문제에 대해 배울 수 있을 것입니다.&lt;/P&gt;
&lt;P&gt;좋은 사용자 인터페이스 설계는 생각처럼 어려운 것이 아니고 사용자들이 당신의 제품을 구입하고 사용하게 하는데 있어서 절대적으로 중요합니다. 짧은 프로그래머 입문서로 &lt;A href="http://www.joelonsoftware.com/uibook/chapters/fog0000000057.html"&gt;UI 설계에 관해 필자가 쓴 무료 온라인 책&lt;/A&gt;을 읽어보실 수 있습니다.&lt;/P&gt;
&lt;P&gt;하지만 사용자 인터페이스에서 제일 중요한 것은 많은 사람들에게 당신의 프로그램을 보여주면(5~6명이면 충분합니다) 제일 큰 문제점을 빠른 시간에 발견할 수 있다는 것입니다. &lt;A href="http://www.useit.com/alertbox/20000319.html"&gt;Jakob Nielsen의 글&lt;/A&gt;에서 그 이유에 대한 설명을 찾을 수 있습니다. UI 설계 경험이 별로 없다고 하더라도 - 비용이 전혀 들지 않는 - 무작위 사용성 테스트를 한다면 당신의 UI는 훨씬 좋아질 것입니다.&lt;/P&gt;
&lt;P&gt;&lt;STRONG&gt;Joel Test를 사용하는 4가지 방식&lt;/STRONG&gt; &lt;/P&gt;
&lt;OL&gt;
&lt;LI&gt;자신이 속한 소프트웨어 팀의 점수를 매기고 그것에 대해 언급할 수 있도록 결과에 대한 이유를 필자에게 알려주십시오. 
&lt;LI&gt;프로그래머 팀의 관리자라면, 당신의 팀이 최대한 잘 운영될 수 있는지 확인할 수 있는 지표로 사용하십시오. 12점을 받기 시작하면 &lt;A href="http://www.joelonsoftware.com/articles/fog0000000072.html"&gt;프로그래머들을 간섭없이 그냥 두고&lt;/A&gt; 비즈니스쪽 사람들이 그들을 간섭하지 못하게 하는데에 모든 시간을 할 수 있습니다. 
&lt;LI&gt;프로그래머 일을 맡을지를 결정해야하는 상황이라면 그 팀의 친한 사람에게 이 테스트 결과가 어떤지를 물어보십시오. 결과 점수가 너무 낮다면 이를 고칠 수 있는 권한을 받을 것인지를 확인하십시오. 그렇지 않으면 불만과 스트레스에 빠질 것입니다. 
&lt;LI&gt;프로그래밍 팀을 평가하여야 하는 투자자이거나 당신의 회사가 다른 소프트웨어 회사와 합병을 한다면 이 평가가 급한대로 괜찮은 지표가 될 것입니다. &lt;/LI&gt;&lt;/OL&gt;&lt;br /&gt;&lt;br /&gt;&lt;font style="FONT-FAMILY: Georgia, Times, serif" color="#808080" size="2"&gt;
이 기사는 영어로  &lt;A href="http://www.joelonsoftware.com/articles/fog0000000043.html"&gt;The Joel Test: 12 Steps to Better Code&lt;/A&gt; 라는 이름의 기사가 원본입니다.&lt;/font&gt;&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td valign="bottom" width="178"&gt;


&lt;font size="2"&gt;&lt;a href="http://joel.spolsky.com/"&gt;&lt;img height="116" src="../Images/TinyJoel.jpg" width="116" border="0" /&gt;&lt;/a&gt;&lt;br /&gt;&lt;font color="#808080"&gt;Joel Spolsky는 뉴욕에 위치한 작은 소프트웨어 회사인 &lt;A href="http://www.fogcreek.com"&gt;Fog Creek Software&lt;/A&gt;의 창업자입니다. 예일 대학교를 졸업하고 Microsoft, Viacom, Juno등에서 프로그래머와 매니저로 일했습니다.&lt;/font&gt;
   
&lt;/font&gt;


&lt;/td&gt;&lt;/tr&gt;

&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;
&lt;p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;/p&gt;
&lt;p align="center"&gt;&lt;font size="2"&gt;이 페이지의 내용은 한사람의 의견을 대변합니다.&lt;br /&gt;&lt;/font&gt;&lt;font size="2"&gt;All contents Copyright&amp;nbsp;©1999-2005 &amp;nbsp;by Joel Spolsky. All Rights Reserved.&lt;/font&gt;&lt;/p&gt;
&lt;p style="FONT-FAMILY: arial,helvetica,sans-serif" align="center"&gt;&lt;font size="2"&gt;&lt;a href="http://www.fogcreek.com/FogBUGZ"&gt;&lt;font size="2"&gt;FogBUGZ&lt;/font&gt;&lt;/a&gt; | &lt;a href="http://www.fogcreek.com/CityDesk"&gt;CityDesk&lt;/a&gt; | &lt;a href="http://www.fogcreek.com/"&gt;Fog Creek Software&lt;/a&gt; | &lt;a href="http://joel.spolsky.com/"&gt;Joel Spolsky&lt;/a&gt;&lt;/font&gt;&lt;/p&gt;&lt;/BODY&gt;&lt;/HTML&gt;</value>
  </data>
</root>